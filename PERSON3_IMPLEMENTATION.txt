/*
Author: Person 3
Class: ECE6122
Last Date Modified: November 29, 2025

Description:
Implementation Guide for Person 3 - Flight Control System
This document explains the complete implementation of the UAV flight control system
including the state machine and PID controller.
*/

===============================================================================
PERSON 3 IMPLEMENTATION OVERVIEW
===============================================================================

As Person 3 (The Pilot), you are responsible for implementing the "brain" of 
the UAV system. Your code calculates the control forces that tell the UAVs 
where to go and how to fly.

===============================================================================
FILES CREATED/MODIFIED
===============================================================================

NEW FILES:
1. code/PIDController.h        - PID controller class header
2. code/PIDController.cpp      - PID controller implementation
3. PERSON3_IMPLEMENTATION.txt  - This documentation file

MODIFIED FILES:
1. code/ECE_UAV.h             - Added state machine enum and control functions
2. code/ECE_UAV.cpp           - Implemented state-based control logic

===============================================================================
ARCHITECTURE
===============================================================================

The implementation follows a State Machine pattern with four states:

┌─────────┐  5 sec   ┌─────────┐  reach   ┌─────────┐  60 sec  ┌──────────┐
│  IDLE   │ ────────>│ ASCENT  │ ───────> │  ORBIT  │ ───────> │ FINISHED │
└─────────┘          └─────────┘  (0,0,50) └─────────┘          └──────────┘
   Hold                Fly up              Sphere orbit           Complete
  Ground              Max 2 m/s            2-10 m/s

===============================================================================
STATE MACHINE DETAILS
===============================================================================

STATE A: IDLE (0-5 seconds)
----------------------------
Purpose: Keep UAV stationary on the ground for the first 5 seconds

Implementation:
- Apply upward force equal to gravity (10 N) to counter gravitational pull
- Force velocity to zero to ensure no movement
- Monitor elapsed time to transition to ASCENT after 5 seconds

Code Location: ECE_UAV.cpp, calculateStateBasedForce(), lines ~170-185

Key Variables:
- elapsedTime: Time since simulation start
- gravityCompensation: 10.0 N (mass * 10 m/s²)


STATE B: ASCENT
---------------
Purpose: Fly from ground position to the target point (0, 0, 50 m)

Constraints:
- Maximum velocity: 2 m/s
- Target: Point (0, 0, 50)

Implementation:
- Calculate vector from current position to target (0, 0, 50)
- Normalize direction and apply force in that direction
- Monitor current speed; if exceeding 2 m/s, apply braking force
- Transition to ORBIT when within 10m of target (sphere radius)

Code Location: ECE_UAV.cpp, calculateStateBasedForce(), lines ~187-220

Key Formulas:
- Direction: targetPoint - currentPosition
- Force: direction.normalized() * maxForce (20 N)
- Speed check: velocity.magnitude() <= 2.0


STATE C: ORBIT
--------------
Purpose: Fly randomly along the surface of a 10m radius sphere centered at 
(0, 0, 50) for 60 seconds

Constraints:
- Sphere center: (0, 0, 50)
- Sphere radius: 10 m
- Velocity range: 2-10 m/s
- Duration: 60 seconds

Implementation Strategy:
The orbit control uses a combination of:
1. PID Controller - Maintains distance from sphere center
2. Tangential Forces - Creates random movement along surface
3. Speed Control - Keeps velocity in allowed range

PID Control for Radial Distance:
--------------------------------
Error = desiredRadius - actualRadius
Error = 10.0 - distance(currentPosition, sphereCenter)

The PID controller calculates a corrective force:
- Proportional Term: Immediate response to distance error
- Integral Term: Eliminates steady-state offset
- Derivative Term: Dampens oscillations

Radial Force = PID_output * radialDirection
This force pushes the UAV toward/away from center to maintain radius.

Tangential Movement:
-------------------
To create random flight paths along the sphere surface:
1. Generate random direction vector
2. Project onto tangent plane (perpendicular to radial direction)
3. Apply tangential force to create sideways motion
4. Change direction periodically (~every 1 second)

Speed Control:
-------------
- If speed < 2 m/s: Apply acceleration force
- If speed > 10 m/s: Apply braking force
- Otherwise: Maintain current speed

Total Force Calculation:
-----------------------
totalForce = radialCorrectionForce + tangentialForce + gravityCompensation

Code Location: ECE_UAV.cpp, calculateStateBasedForce(), lines ~222-305


STATE D: FINISHED
-----------------
Purpose: Hold position after orbit complete

Implementation:
- Apply only gravity compensation force
- UAV hovers in place

Code Location: ECE_UAV.cpp, calculateStateBasedForce(), lines ~307-312

===============================================================================
PID CONTROLLER IMPLEMENTATION
===============================================================================

The PID controller is the mathematical heart of the orbit control system.

PID Formula:
-----------
output = Kp * error + Ki * ∫(error·dt) + Kd * d(error)/dt

Where:
- Kp = Proportional gain
- Ki = Integral gain  
- Kd = Derivative gain
- error = setpoint - processVariable

Tuned Gains (in ECE_UAV constructor):
-------------------------------------
Kp = 50.0   // Strong proportional response
Ki = 0.5    // Small integral to prevent windup
Kd = 10.0   // Moderate derivative for damping

These values were chosen based on:
- UAV mass: 1 kg
- Max force: 20 N
- Desired response time: ~1 second
- Sampling rate: 100 Hz (10 ms updates)

Tuning Guidelines:
-----------------
If UAVs oscillate around sphere: DECREASE Kp or INCREASE Kd
If UAVs drift from sphere: INCREASE Kp or INCREASE Ki
If response is too slow: INCREASE Kp
If response overshoots: INCREASE Kd

Code Location: 
- PIDController.h/cpp - Complete PID implementation
- ECE_UAV.cpp, line ~140 - PID gains initialization

===============================================================================
ECE6122 REQUIREMENT: COLOR OSCILLATION
===============================================================================

For ECE6122 students, the UAV color must oscillate between full and half 
intensity at 0.5 Hz.

Implementation:
--------------
colorPhase += 2π * 0.5 * deltaTime
intensity = 0.75 + 0.25 * sin(colorPhase)

This creates oscillation between:
- Maximum: 0.75 + 0.25 = 1.0 (full color)
- Minimum: 0.75 - 0.25 = 0.5 (half color)

Frequency: 2π * 0.5 = π radians/second ≈ 0.5 Hz

Usage:
-----
Person 1 should call getColorIntensity() when rendering UAVs to get the 
current color multiplier.

Example: 
UAV_Color = BaseColor * getColorIntensity()

Code Location: ECE_UAV.cpp, lines ~145-155 and line ~163

===============================================================================
DATA FLOW SUMMARY
===============================================================================

Every 10 milliseconds (in threadFunction):

1. PERSON 3 (calculateStateBasedForce):
   ↓
   - Read current position, velocity, acceleration
   - Determine current state (IDLE, ASCENT, ORBIT, FINISHED)
   - Calculate appropriate control force vector
   ↓
2. PERSON 2 (updateKinematics):
   ↓
   - Add gravity force: totalForce = controlForce + gravity
   - Calculate acceleration: a = F/m
   - Update velocity: v = v₀ + a·t
   - Update position: x = x₀ + v₀·t + ½·a·t²
   ↓
3. PERSON 2 (checkCollisionsFor):
   ↓
   - Check for collisions with other UAVs
   - Swap velocities if collision detected
   ↓
4. Sleep 10ms and repeat

Every 30 milliseconds (in main thread):

1. PERSON 1:
   - Poll getPosition() for all UAVs
   - Call getColorIntensity() for ECE6122 students
   - Render 3D scene with updated positions and colors

===============================================================================
THREAD SAFETY
===============================================================================

All member variables are protected by dataMutex:
- position, velocity, acceleration
- currentState
- colorPhase

Public getter/setter functions use std::lock_guard to ensure thread-safe access.

Important: The calculateStateBasedForce() function already locks the mutex
internally, so Person 1 and Person 2 don't need additional locking.

===============================================================================
TESTING AND DEBUGGING
===============================================================================

Debug Output:
------------
The code includes console output for state transitions:
- "UAV transitioning to ASCENT state"
- "UAV transitioning to ORBIT state"
- "UAV finished orbit - simulation complete"

Verification Checklist:
----------------------
□ UAVs remain stationary for first 5 seconds
□ UAVs launch upward after 5 seconds
□ Ascent velocity never exceeds 2 m/s
□ UAVs reach vicinity of (0, 0, 50)
□ UAVs orbit on sphere surface (radius ≈ 10m)
□ Orbit velocity stays between 2-10 m/s
□ UAVs fly for 60 seconds on sphere
□ Simulation ends after orbit complete
□ [ECE6122] Color oscillates at ~0.5 Hz

Common Issues:
-------------
1. UAVs fall through ground
   → Check that IDLE state applies upward force
   
2. UAVs overshoot target
   → Increase Kd gain for more damping
   
3. UAVs drift from sphere
   → Increase Kp gain for stronger correction
   
4. UAVs fly too fast/slow
   → Adjust tangential force magnitude in ORBIT state
   
5. Collision detection not working
   → Verify GLOBAL_UAV_LIST is properly initialized by Person 1

===============================================================================
INTEGRATION WITH PERSON 1 AND PERSON 2
===============================================================================

Person 1 (The Architect):
------------------------
Required from Person 1:
- Initialize ECE_UAV objects with starting positions
- Call start() method to launch threads
- Poll getPosition() every 30ms for rendering
- [ECE6122] Call getColorIntensity() for color rendering
- Initialize GLOBAL_UAV_LIST for collision detection

Person 2 (The Physicist):
------------------------
Required from Person 2:
- Implement updateKinematics() with F=ma and kinematic equations
- Implement checkCollisionsFor() with elastic collision logic
- Ensure proper mutex handling in physics calculations

Person 3 (You):
--------------
Your deliverables:
✓ PIDController.h and PIDController.cpp
✓ State machine enum in ECE_UAV.h
✓ State machine implementation in ECE_UAV.cpp
✓ calculateStateBasedForce() function
✓ Color oscillation logic (ECE6122)
✓ This documentation file

===============================================================================
CODING STANDARDS COMPLIANCE
===============================================================================

✓ Indentation: 4 spaces
✓ Camel case: Variable and function names follow camelCase
✓ File headers: All files include proper headers with author, class, date
✓ Function comments: All functions documented with purpose, inputs, outputs
✓ Class comments: ECE_UAV and PIDController classes fully documented
✓ Inline comments: Complex logic sections have explanatory comments
✓ No warnings: Code compiles cleanly with -Wall

===============================================================================
EXTRA CREDIT OPPORTUNITIES
===============================================================================

Implemented:
✓ ECE6122: Color oscillation at 0.5 Hz

Potential additions:
□ +20 points: Texture mapping on UAV 3D models
□ +10 points: Football field texture (ff.bmp)

Note: These would be implemented by Person 1 in the rendering code.

===============================================================================
MATHEMATICAL REFERENCE
===============================================================================

Newton's Second Law:
F = m·a
a = F/m

Kinematic Equations (constant acceleration):
x = x₀ + v₀·t + ½·a·t²
v = v₀ + a·t

PID Control:
u(t) = Kp·e(t) + Ki·∫e(τ)dτ + Kd·de(t)/dt

Discrete PID (for 10ms updates):
P = Kp · error
I = Ki · Σ(error · Δt)
D = Kd · (error - error_prev) / Δt
output = P + I + D

Vector Projection (for tangent plane):
tangent = vector - radial · (vector · radial)

===============================================================================
CONTACT AND COLLABORATION
===============================================================================

Person 3 provides:
- Control force vector output via calculateStateBasedForce()
- Position data via getPosition()
- Color intensity via getColorIntensity()

Person 3 requires from Person 1:
- Properly initialized UAV objects
- GLOBAL_UAV_LIST populated with all UAVs
- Thread start() called after initialization

Person 3 requires from Person 2:
- Working updateKinematics() implementation
- Working checkCollisionsFor() implementation
- Proper thread-safe access to kinematics data

===============================================================================
END OF DOCUMENTATION
===============================================================================
